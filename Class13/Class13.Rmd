---
title: "Class13"
author: 'Brooke Clements (PID: 17532793)'
date: "2026-02-19"
output: pdf_document
---
This week we are looking at differential expression enalysis. 

The data for this hands-on session comes from a published RNA-seq experiment where airway smooth muscle cells were treated with dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014).


## Import countData and colData

```{r}
download.file("https://bioboot.github.io/bimm143_W18/class-material/airway_scaledcounts.csv", destfile = "airway_scaledcount.csv")
download.file("https://bioboot.github.io/bimm143_W18/class-material/airway_metadata.csv", destfile = "airway_metadata.csv")
```

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcount.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

```{r}
head(metadata)
```
Sanity check on correspondence of counts and metadata  

```{r}
all (metadata$id == colnames(counts))
```

> Q1. How many genes are in this dataset?

There are `r nrow(counts)` genes in this dataset.


> Q2. How many ‘control’ cell lines do we have?

```{r include=FALSE}
n.control <- sum(metadata$dex == "control")
```
There are `r n.control` control cell lines in this dataset. 

## Extract and summerize the control samples

To find out where the control samples are we need the metadata

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowMeans(control.counts)
head(control.mean)
```

## Extract and summarize the treated (i.e. drug) samples

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called `treated.mean`)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts [, treated$id]
treated.mean <- rowMeans(treated.counts)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

Lets make a plot to explore thee results a little. 
> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated")
```
> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

```{r}
library(ggplot2)

ggplot(meancounts) +
  aes(control.mean, treated.mean) +
  geom_point()
```

We will make a log-log plot to draw out this skewed data and see ehat is going on. 
> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

```{r}
plot(meancounts[,1],meancounts[,2], log="xy",
     xlab="log control counts",
     ylab="log of treated counts")
```

```{r}
ggplot(meancounts) +
  aes(x=control.mean, y=treated.mean) +
  geom_point() +
  scale_x_continuous(trans="log2") +
  scale_y_continuous(trans="log2") +
  xlab("log control counts") +
  ylab("log of treated counts") 
   
```

We often log2 transformations when dealing with the sort of data. 

```{r}
log2(20/20)
```

```{r}
log2(40/20)
```

```{r}
log2(20/40)
```

```{r}
log2(80/20)
```


This log2 transformation has this nice property where if there is no change the log2 value will be zero and if it double the log will be q and if halved it will be -1. 

So lets add a log2 fold change column to our results so far

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

We need to get rid of zero count genes that we can not say anything about

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> How many genes are remaning? 

```{r}
nrow(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind tells us which rows and columns the true values are in. The unique () function is so we do not remove the same row multiple times. 

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

# Use fold change to see up and down regulated genes. 

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

```{r}
sum(up.ind)
```

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(down.ind)
```

>Q10. Do you trust these results? Why or why not?

Not fully because we don't yet know if these changes are significant. 

# Setting up for DESeq

Let’s do this the right way. DESeq2 is an R package specifically for analyzing count-based NGS data like RNA-seq. It is available from Bioconductor. Bioconductor is a project to provide tools for analyzing high-throughput genomic data including RNA-seq, ChIP-seq and arrays. 

```{r message=FALSE}
#load up DESeq2
library(DESeq2)
```


```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
res
```

We can get some bssic summary tallies using the `summary()` function. 

```{r}
summary(res, alpha=0.05)
```

## Principal Component Analysis (PCA)

```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```

```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```

```{r}
# Calculate percent variance per PC for the plot axis labels
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

```{r}
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

## Adding annotation data

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```
```{r}
columns(org.Hs.eg.db)
```

```{r}
AnnotationDbi::select
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
```
We need to add missing annotation data to our main “res” result object. This includes the common gene symbol

```{r}
head(res)
```

> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

We can use the `mapIds()` function now to “translate” between any of these databases

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

Finish for today by saving our results

```{r}
write.csv(res[ord,], "deseq_results.csv")
```

# Volcano Plot
Make a summary plot of our results

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

```{r}
library(EnhancedVolcano)
```

```{r}
x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```

## Pathway Analysis

What known biological pathways do our differentially expressed genes overlap with (i.e play a role in)? 
There lot’s of bioconductor packages to do this type of analysis. 
We will use one of the oldest called **gage** along with **pathview** to render nice pics of the pathways we find. 

We can instal these with the command : 
`BioManager::instal(c(“pathview”, “gage”, “gageData”))`

```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

Have a wee peak what is in `gage`

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```
```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310", kegg.native=FALSE)
```



